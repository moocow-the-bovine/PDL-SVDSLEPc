##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

our $VERSION = "0.001";
pp_setversion($VERSION);

do "./Config.cache";
if ($@) {
  warn("$0: could not load cache data from './Config.cache': $@");
}

##------------------------------------------------------
## Header: index type
require PDL::Core;
my ($INDX,$INDX_P,$INDX_C);
if ($cconfig{PETSC_USE_64BIT_INDICES}) {
  if (defined(&PDL::indx)) {
    ##-- use this to support 64-bit indices with PDL_Indx (but which() and friends don't return them!)
    #print STDERR "PDL >= v2.007 detected : using built-in PDL_Indx type\n";
    $INDX   = 'indx';
    $INDX_P = 'indx';
    $INDX_C = 'PDL_Indx';
  } else {
    $INDX   = 'longlong';
    $INDX_P = 'longlong';
    $INDX_C = 'PDL_LongLong';
  }
} else {
  $INDX   = 'int';
  $INDX_P = 'long';
  $INDX_C = 'PDL_Long';
}


##------------------------------------------------------
## Header: pods
pp_addpm({At=>'Top'},<<'EOPM');
=pod

=head1 NAME

PDL::SVDSLEPc - PDL interface to SLEPc sparse singular value decomposition

=head1 SYNOPSIS

 use PDL;
 use PDL::SVDSLEPc;

 ##---------------------------------------------------------------------
 ## Input matrix (dense)
 ##---------------------------------------------------------------------
 $m = 100;                    ##-- number of rows
 $n = 50;                     ##-- number of columns
 $a = random(double,$m,$n);   ##-- random matrix

 ##---------------------------------------------------------------------
 ## Input matrix (sparse)
 ##---------------------------------------------------------------------
 $d  = 0.1;                   ##-- target density of sparse matrix
 $ix = (random(2,$d*$m*$n)    ##-- random whichND()-style index piddle
         * pdl([$m,$n])       ##   ... of dimension ($m,$n)
        )->long               ##   ... as integer values
         ->uniqvec;           ##   ... ensure uniqueness
 $nnz = $wnd->dim(1);         ##-- number of non-zeroes
 $nz  = random($nnz);         ##-- random non-zero values

 ##---------------------------------------------------------------------
 ## Output pdls [TODO]
 ##---------------------------------------------------------------------
 $d  = $n;                   ##-- max number of output dimensions
 $ut = zeroes(double,$m,$d); ##-- left singular components
 $s  = zeroes(double,$d);    ##-- singular values (diagnonal vector)
 $vt = zeroes(double,$n,$d); ##-- right singular components

 ##---------------------------------------------------------------------
 ## Singular Value Decomposition [TODO]
 ##---------------------------------------------------------------------
 svdlas2d($a, $maxiters, $end, $kappa, $ut, $s, $vt);

=head1 DESCRIPTION

PDL::SVDLIBC provides a PDL interface to the SVDLIBC routines
for singular value decomposition of large sparse matrices.
SVDLIBC is available from http://tedlab.mit.edu/~dr/SVDLIBC/

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();


##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');

#include <slepcversion.h>
#include <petscmat.h>
#include <slepcsvd.h>

/*#define CDEBUG 1*/
/*#define DEBUG_CODE 1*/

//-- ganked from slepc4py
#define MPICH_SKIP_MPICXX 1
#define OMPI_SKIP_MPICXX 1

EOH

##======================================================================
## C Utilities
##======================================================================

pp_addhdr(<<'EOH');

void svdslepc_init(int argc, const char **argv, const char *help)
{
  SlepcInitializeNoPointers(argc, (char**)argv, NULL, help);
}

/* PAIN AND ANGUISH:
 * + passing in char *args gives garbage for all but the 1st element if we NUL-terminate on the perl side
 * + if we \n-terminate, we need to duplicate *args
 */
void svdslepc_init_func(const char *func, const char *args, int nargs, const char *help)
{
  int argc=1+nargs,i,ai;
  const char **argv;

  //-- allocate argv
  argv = (const char**)malloc(argc*sizeof(char*));
  argv[0] = func;
  for (ai=1,i=0; ai < argc; ++ai, ++i) {
    argv[ai] = args+i;
    for (; args[i] && args[i] != '\n'; ++i) ;
  }

  //-- call underlying init function
  svdslepc_init(argc, argv, help);

  //-- cleanup
  if (argv) free(argv);
}

void svdslepc_finish(void)
{
  SlepcFinalize();
}

EOH

##======================================================================
## PDL::PP Wrappers
##======================================================================

##======================================================================
## Constants
pp_addpm(<<'EOPM');

use strict;

=pod

=head1 CONSTANTS

PDL::SVDSLEPc provides access to the following SLEPc constants:


EOPM

##--------------------------------------------------------------
## Constants: slepc_version
pp_addpm(<<'EOPM');

=pod

=head2 PDL::SVDSLEPc::slepc_version()

Returns a string representing the SLEPc library version
this module was compiled with.

=cut

EOPM

pp_addxs('','

char *
slepc_version()
INIT:
  char buf[PETSC_MAX_PATH_LEN];
CODE:
  SlepcGetVersion(buf,PETSC_MAX_PATH_LEN);
  RETVAL = buf;
OUTPUT:
  RETVAL

');

##--------------------------------------------------------------
## Constants: petsc_version
pp_addpm(<<'EOPM');

=pod

=head2 PDL::SVDSLEPc::petsc_version()

Returns a string representing the PETSc library version
this module was compiled with.

=cut

EOPM

pp_addxs('','

char *
petsc_version()
INIT:
  char buf[PETSC_MAX_PATH_LEN];
CODE:
  PetscGetVersion(buf,PETSC_MAX_PATH_LEN);
  RETVAL = buf;
OUTPUT:
  RETVAL

');

##--------------------------------------------------------------
## Constants: library_version
pp_addpm(<<'EOPM');

=pod

=head2 PDL::SVDSLEPc::library_version()

In list context returns a pair C<(slepc_version(),petsc_version())>,
in scalar context returns a string with both versions separated
with a semicolon.

=cut

sub library_version {
  my @v = (slepc_version(),petsc_version());
  return wantarray ? @v : join('; ', @v);
}

EOPM

##--------------------------------------------------------------
## Constants: MPI_Comm_size
pp_addpm(<<'EOPM');

=pod

=head2 PDL::SVDSLEPc::MPI_Comm_size()

Returns the number of MPI processes available.

=cut

EOPM

pp_addxs('','

int
MPI_Comm_size()
PREINIT:
  PetscErrorCode ierr;
  PetscMPIInt size;
  const char *argv[] = {"PDL::SVDSLEPc::MPI_Comm_size"};
CODE:
  svdslepc_init(1,argv,NULL);
  ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRV(ierr);
  RETVAL = size;
OUTPUT:
  RETVAL
CLEANUP:
  svdslepc_finish();

');


##======================================================================
## SVD Utilities

pp_addpm(<<'EOPM');

=pod

=head1 SVD UTILITIES

The following functions are provided as quick and dirty wrappers
for the SLEPc L<SVD|http://slepc.upv.es/documentation/current/docs/manualpages/SVD/index.html>
solver class.

=cut

EOPM

##------------------------------------------------------
## slepc_svd_help() : help string for svd routine

pp_add_exported('','slepc_svd_help');
pp_addpm(<<'EOPM');

=pod

=head2 slepc_svd_help

=for sig

 Signature: ()


Prints a help message with all supported SLEPc options to STDOUT.

=cut

EOPM

pp_addxs('','

void
slepc_svd_help()
PREINIT:
  PetscErrorCode ierr;
  const char *argv[2]  = {"PDL::SVDSLEPc::slepc_svd_help","-help"};
  PetscInt m=4,n=3,nz=0;
  Mat            A;
  SVD          svd;             /* singular value problem solver context */
CODE:
  svdslepc_init(2,argv,NULL);
  ierr = MatCreateSeqAIJFromTriple(MPI_COMM_WORLD, m,n, NULL,NULL,NULL, &A,nz,PETSC_FALSE);
  ierr = SVDCreate(PETSC_COMM_WORLD,&svd);CHKERRV(ierr);
  ierr = SVDSetOperator(svd,A);CHKERRV(ierr);
  ierr = SVDSetFromOptions(svd);CHKERRV(ierr);
  ierr = SVDSolve(svd);CHKERRV(ierr);
CLEANUP:
  ierr = SVDDestroy(&svd);CHKERRV(ierr);
  ierr = MatDestroy(&A);CHKERRV(ierr);
  svdslepc_finish();

');


##------------------------------------------------------
## slepc_svd_crs() : svd with native compressed row storage representation (no memory bloat)

pp_add_exported('','_slepc_svd_crs');
pp_def
  ('_slepc_svd_crs',
   Pars => join("\n    ",
		'',
		qq($INDX  rowptr(mplus1);),
		qq($INDX  colids(nnz);),
		qq(double nzvals(nnz);),
		qq( u(d,m);),
		qq( s(d);),
		qq( v(d,n);),
		'',
	       ),
   OtherPars => qq(IV optsArray;),
   Code =>
('
  const char *argv[1]  = {"PDL::SVDSLEPc::_slepc_svd_crs"};
  PetscErrorCode ierr;
  Mat A;
  SVD svd;
  AV *optsav = INT2PTR(AV*, $COMP(optsArray));

  //svdslepc_init_func("PDL::SVDSLEPc::_slepc_svd_crs",$COMP(opts),$COMP(nopts),NULL);
  ierr = MatCreateSeqAIJWithArrays(MPI_COMM_WORLD, $SIZE(m),$SIZE(n), $P(rowptr),$P(colids),$P(nzvals), &A);CHKERRV(ierr);
  ierr = SVDCreate(PETSC_COMM_WORLD,&svd);CHKERRV(ierr);
  ierr = SVDSetOperator(svd,A);CHKERRV(ierr);
  ierr = SVDSetFromOptions(svd);CHKERRV(ierr);
  ierr = SVDSolve(svd);CHKERRV(ierr);

  //-- todo: get output data

  //-- cleanup
  ierr = SVDDestroy(&svd);CHKERRV(ierr);
  ierr = MatDestroy(&A);CHKERRV(ierr);
  svdslepc_finish();
'),
   Doc =>
q(
TODO
),
);




##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## footer: pm additions
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

SLEPc by Carmen Campos, Jose E. Roman, Eloy Romero, and Andres Tomas.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

=head2 no abstract interface

There should really be a more general and abstract PDL interface to SLEPc/PETsc.


=head2 OpenMPI Errors

You might see OpenMPI errors such as the following when trying to use this module:

 mca: base: component find: unable to open /usr/lib/openmpi/lib/openmpi/mca_paffinity_hwloc: perhaps a missing symbol, or compiled for a different version of Open MPI? (ignored)

If you do, you probably need to configure your runtime linker to pre-load the OpenMPI libraries, e.g. with

 export LD_PRELOAD=/usr/lib/libmpi.so

or similar.  An alternative is to build OpenMPI with the C<--disable-dlopen> option.
See L<http://www.open-mpi.org/faq/?category=troubleshooting#missing-symbols> for details.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@cpan.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2015, Bryan Jurish.  All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself, either version 5.20.2 or any newer version of Perl 5
you have available.

=head1 SEE ALSO

L<perl(1)|perl>,
L<PDL(3perl)|PDL>,
L<PDL::CCS(3perl)|PDL::CCS>,
L<PDL::SVDLIBC(3perl)|PDL::SVDLIBC>,
the SLEPc documentation at L<http://slepc.upv.es/documentation/current/docs/index.html>.

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
