##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

our $VERSION = "0.001";
pp_setversion($VERSION);

do "./Config.cache";
if ($@) {
  warn("$0: could not load cache data from './Config.cache': $@");
}

##------------------------------------------------------
## Header: index type
require PDL::Core;
my ($INDX,$INDX_P,$INDX_C);
if ($cconfig{PETSC_USE_64BIT_INDICES}) {
  if (defined(&PDL::indx)) {
    ##-- use this to support 64-bit indices with PDL_Indx (but which() and friends don't return them!)
    #print STDERR "PDL >= v2.007 detected : using built-in PDL_Indx type\n";
    $INDX   = 'indx';
    $INDX_P = 'indx';
    $INDX_C = 'PDL_Indx';
 } else {
    $INDX   = 'longlong';
    $INDX_P = 'longlong';
    $INDX_C = 'PDL_LongLong';
  }
} else {
  $INDX   = 'int';
  $INDX_P = 'long';
  $INDX_C = 'PDL_Long';
}


##------------------------------------------------------
## Header: pods
pp_addpm({At=>'Top'},<<'EOPM');
=pod

=head1 NAME

PDL::SVDSLEPc - PDL interface to SLEPc sparse singular value decomposition

=head1 SYNOPSIS

 use PDL;
 use PDL::SVDSLEPc;

 ##---------------------------------------------------------------------
 ## Input matrix (dense)
 ##---------------------------------------------------------------------
 $m = 100;                    ##-- number of rows
 $n = 50;                     ##-- number of columns
 $a = random(double,$m,$n);   ##-- random matrix

 ##---------------------------------------------------------------------
 ## Input matrix (sparse)
 ##---------------------------------------------------------------------
 $d  = 0.1;                   ##-- target density of sparse matrix
 $ix = (random(2,$d*$m*$n)    ##-- random whichND()-style index piddle
         * pdl([$m,$n])       ##   ... of dimension ($m,$n)
        )->long               ##   ... as integer values
         ->uniqvec;           ##   ... ensure uniqueness
 $nnz = $wnd->dim(1);         ##-- number of non-zeroes
 $nz  = random($nnz);         ##-- random non-zero values

 ##---------------------------------------------------------------------
 ## Output pdls [TODO]
 ##---------------------------------------------------------------------
 $d  = $n;                   ##-- max number of output dimensions
 $ut = zeroes(double,$m,$d); ##-- left singular components
 $s  = zeroes(double,$d);    ##-- singular values (diagnonal vector)
 $vt = zeroes(double,$n,$d); ##-- right singular components

 ##---------------------------------------------------------------------
 ## Singular Value Decomposition [TODO]
 ##---------------------------------------------------------------------
 svdlas2d($a, $maxiters, $end, $kappa, $ut, $s, $vt);

=head1 DESCRIPTION

PDL::SVDLIBC provides a PDL interface to the SVDLIBC routines
for singular value decomposition of large sparse matrices.
SVDLIBC is available from http://tedlab.mit.edu/~dr/SVDLIBC/

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();


##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');

#include <slepcversion.h>
#include <petscmat.h>
#include <slepcsvd.h>

/*#define SVDSLEPC_DEBUG 1*/
#ifdef SVDSLEPC_DEBUG
# define SVDDEBUG(x) x
#else
# define SVDDEBUG(x)
#endif

//-- ganked from slepc4py
#define MPICH_SKIP_MPICXX 1
#define OMPI_SKIP_MPICXX 1

EOH

##======================================================================
## C Utilities
##======================================================================

pp_addhdr(<<'EOH');

void svdslepc_init(int argc, const char **argv, const char *help)
{
  SlepcInitializeNoPointers(argc, (char**)argv, NULL, help);
}

/* PAIN AND ANGUISH:
 * + passing in char *args gives garbage for all but the 1st element if we NUL-terminate on the perl side
 * + if we \n-terminate, we need to duplicate *args
 */
void svdslepc_init_func(const char *func, AV *args, const char *help, int *pargc, const char ***pargv)
{
  int ai, nopts=1+av_len(args);

  //-- allocate argv
  *pargc = 1+nopts;
  *pargv = (const char**)malloc((*pargc)*sizeof(char*));
  (*pargv)[0] = func;
  SVDDEBUG(fprintf(stderr,"init_func: argv[0/%d] = %s\n", nopts, (*pargv)[0]);)
  for (ai=0; ai < nopts; ++ai) {
    (*pargv)[ai+1] = SvPV_nolen(*av_fetch(args, ai, 0));
    SVDDEBUG(fprintf(stderr,"init_func: argv[%d/%d] = %s\n", ai+1, nopts, (*pargv)[ai+1]);)
  }

  //-- call underlying init function
  svdslepc_init(*pargc, *pargv, help);
}

void svdslepc_finish()
{
  SlepcFinalize();
}

void svdslepc_finish_func(int argc, const char **argv)
{
  svdslepc_finish();
  if (argv) free(argv);
}

EOH

##======================================================================
## Bootstrap code: MPI stuff

pp_add_boot(<<'EOB');
  MPI_Init(0,NULL);
EOB

pp_addpm(<<'EOPM');
END { _svdslepc_END(); }
EOPM

##======================================================================
## PDL::PP Wrappers
##======================================================================

##======================================================================
## Constants
pp_addpm(<<'EOPM');

use strict;

=pod

=head1 CONSTANTS

PDL::SVDSLEPc provides access to the following SLEPc constants:


EOPM

##--------------------------------------------------------------
## Constants: slepc_version
pp_addpm(<<'EOPM');

=pod

=head2 PDL::SVDSLEPc::slepc_version()

Returns a string representing the SLEPc library version
this module was compiled with.

=cut

EOPM

pp_addxs('','

char *
slepc_version()
INIT:
  char buf[PETSC_MAX_PATH_LEN];
CODE:
  SlepcGetVersion(buf,PETSC_MAX_PATH_LEN);
  RETVAL = buf;
OUTPUT:
  RETVAL

');

##--------------------------------------------------------------
## Constants: petsc_version
pp_addpm(<<'EOPM');

=pod

=head2 PDL::SVDSLEPc::petsc_version()

Returns a string representing the PETSc library version
this module was compiled with.

=cut

EOPM

pp_addxs('','

char *
petsc_version()
INIT:
  char buf[PETSC_MAX_PATH_LEN];
CODE:
  PetscGetVersion(buf,PETSC_MAX_PATH_LEN);
  RETVAL = buf;
OUTPUT:
  RETVAL

');

##--------------------------------------------------------------
## Constants: library_version
pp_addpm(<<'EOPM');

=pod

=head2 PDL::SVDSLEPc::library_version()

In list context returns a pair C<(slepc_version(),petsc_version())>,
in scalar context returns a string with both versions separated
with a semicolon.

=cut

sub library_version {
  my @v = (slepc_version(),petsc_version());
  return wantarray ? @v : join('; ', @v);
}

EOPM

##--------------------------------------------------------------
## Constants: MPI_Comm_size
pp_addpm(<<'EOPM');

=pod

=head2 PDL::SVDSLEPc::MPI_Comm_size()

Returns the number of MPI processes available.
Using multiple MPI processes with mpiexec behaves strangely with perl at the moment,
so this should generally return 1.

=cut

EOPM

pp_addxs('','

int
MPI_Comm_size()
PREINIT:
  PetscErrorCode ierr;
  PetscMPIInt size;
  const char *argv[] = {"PDL::SVDSLEPc::MPI_Comm_size"};
CODE:
  svdslepc_init(1,argv,NULL);
  ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRV(ierr);
  RETVAL = size;
OUTPUT:
  RETVAL
CLEANUP:
  svdslepc_finish();

');

##--------------------------------------------------------------
## Wrappers: END
pp_addxs('',<<'EOXS');

void
_svdslepc_END()
CODE:
  MPI_Finalize();

EOXS


##======================================================================
## SVD Utilities

pp_addpm(<<'EOPM');

=pod

=head1 SVD UTILITIES

The following functions are provided as quick and dirty wrappers
for the SLEPc L<SVD|http://slepc.upv.es/documentation/current/docs/manualpages/SVD/index.html>
solver class.

=cut

EOPM

##------------------------------------------------------
## slepc_svd_help() : help string for svd routine

pp_add_exported('','slepc_svd_help');
pp_addpm(<<'EOPM');

=pod

=head2 slepc_svd_help

=for sig

 Signature: ()

Prints a help message with all supported SLEPc SVD options to STDOUT.
Really just a wrapper for

 _slepc_svd_crs(null,null,null, null,null,null, ['-help']);

=cut

sub slepc_svd_help {
  _slepc_svd_crs(null,null,null, null,null,null, ['-help']);
}

EOPM


##------------------------------------------------------
## slepc_svd_crs() : svd with native compressed row storage representation (no memory bloat)

pp_add_exported('','_slepc_svd_crs');
pp_def
  ('_slepc_svd_crs',
   Pars => join("\n    ",
		'',
		qq($INDX  rowptr(mplus1);),
		qq($INDX  colids(nnz);),
		qq(double nzvals(nnz);),
		qq( u(d,m);),
		qq( s(d);),
		qq( v(d,n);),
		'',
	       ),
   OtherPars => qq(IV optsArray;),
   Code =>
('
  int argc;
  const char **argv;
  PetscErrorCode ierr;
  PetscBool      flg_help, flg_nsv,flg_ncv,flg_mpd;
  PetscInt       i, nsv,ncv,mpd; //-- svd params
  Mat A;
  SVD svd;
  Vec uvec,vvec;
  PetscReal sigma;

  SVDDEBUG(fprintf(stderr,"sizeof(PetscInt)=%d; sizeof($INDX='.$INDX.')=%d; sizeof(PetscScalar)=%d; sizeof(double)=%d\n", sizeof(PetscInt), sizeof($GENERIC(rowptr)), sizeof(PetscScalar), sizeof(double));fflush(stderr);)

  //-- initialize
  SVDDEBUG(fprintf(stderr, "_slepc_svd_crs:init (m=%d, n=%d, nnz=%d, d=%d)\n", $SIZE(m), $SIZE(n), $SIZE(nnz), $SIZE(d));fflush(stderr);)
  svdslepc_init_func("PDL::SVDSLEPc::_slepc_svd_crs",INT2PTR(AV*, $COMP(optsArray)),NULL, &argc,&argv);
  ierr = PetscOptionsHasName(NULL,"-help",&flg_help);CHKERRV(ierr);

  //-- setup (dummy) input matrix
  if ($SIZE(nnz)==0) {
    SVDDEBUG(fprintf(stderr, "setup input matrix (dummy)\n");fflush(stderr);)
    ierr = MatCreateSeqAIJFromTriple(MPI_COMM_WORLD, 1,1, NULL,NULL,NULL, &A,0,PETSC_FALSE);CHKERRV(ierr);
    loop(d) %{
      $s() = 0;
      loop(m) %{ $u() = 0; %}
      loop(n) %{ $v() = 0; %}
    %}
  } else {
    SVDDEBUG(fprintf(stderr, "setup input matrix (real)\n");fflush(stderr);)
    ierr = MatCreateSeqAIJWithArrays(MPI_COMM_WORLD, $SIZE(n),$SIZE(m), $P(rowptr),$P(colids),$P(nzvals), &A);CHKERRV(ierr);
#ifdef SVDDEBUG
    {
      PetscViewer view;
      ierr = PetscViewerBinaryOpen(PETSC_COMM_SELF,"svddebug.petsc",FILE_MODE_WRITE,&view);CHKERRV(ierr);
      ierr = MatView(A,view);CHKERRV(ierr);
      ierr = PetscViewerDestroy(&view);CHKERRV(ierr);
    }
#endif
  }

  //-- setup svd
  SVDDEBUG(fprintf(stderr, "setup svd object\n");fflush(stderr);)
  ierr = SVDCreate(PETSC_COMM_WORLD,&svd);CHKERRV(ierr);
  ierr = SVDSetOperator(svd,A);CHKERRV(ierr);
  ierr = SVDSetFromOptions(svd);CHKERRV(ierr);

  //-- setup #/singular values from input piddles
  SVDDEBUG(fprintf(stderr, "setup #/values\n");fflush(stderr);)
  ierr = PetscOptionsGetInt(NULL,"-svd_nsv",&nsv,&flg_nsv);CHKERRV(ierr);
  if (!flg_nsv || nsv != $SIZE(d)) {
    SVDDEBUG(fprintf(stderr, "set nsv=SIZE(d)=%d\n", $SIZE(d));fflush(stderr);)
    nsv = $SIZE(d);
    ierr = PetscOptionsGetInt(NULL,"-svd_ncv",&ncv,&flg_ncv);CHKERRV(ierr);
    ierr = PetscOptionsGetInt(NULL,"-svd_mpd",&mpd,&flg_mpd);CHKERRV(ierr);
    if (!flg_ncv) ncv = PETSC_DECIDE;
    if (!flg_mpd) mpd = PETSC_DECIDE;
    ierr = SVDSetDimensions(svd,nsv,ncv,mpd);CHKERRV(ierr);
  }
  ierr = SVDGetDimensions(svd,&nsv,&ncv,&mpd);CHKERRV(ierr);

  //-- svd guts
  SVDDEBUG(fprintf(stderr, "compute (nsv=%d, ncv=%d, mpd=%d)\n", nsv, ncv, mpd);fflush(stderr);)
  ierr = SVDSolve(svd);CHKERRV(ierr);

  //-- get output data
  SVDDEBUG(fprintf(stderr, "get output data (m=%d, n=%d, d=%d)\n", $SIZE(m), $SIZE(n), $SIZE(d));fflush(stderr);)
  //ierr = MatCreateVecs(A,&u,&v);CHKERRV(ierr);    //-- documented in petsc-3.6.2, does NOT exist in 3.4.2 (debian wheezy)
  ierr = MatGetVecs(A,&uvec,&vvec);CHKERRV(ierr);
#ifdef SVDSLEPC_DEBUG
  {
    PetscInt nu,nv;
    ierr = VecGetSize(uvec,&nu);CHKERRV(ierr);
    ierr = VecGetSize(vvec,&nv);CHKERRV(ierr);
    fprintf(stderr,"got uvec(%d~m=%d), vvec(%d~n=%d), d=%d\n", nu,$SIZE(m), nv,$SIZE(n), $SIZE(d));fflush(stderr);
  }
#endif

  for (i=0; i < nsv; ++i) {
    PetscScalar *uvals,*vvals;
    ierr = SVDGetSingularTriplet(svd,i,&sigma,vvec,uvec);CHKERRV(ierr);

    $s(d=>i) = sigma;

    ierr = VecGetArray(uvec,&uvals);CHKERRV(ierr);
    loop(m) %{ $u(d=>i) = PetscRealPart(uvals[m]); %}
    ierr = VecRestoreArray(uvec,&uvals);CHKERRV(ierr);

    ierr = VecGetArray(vvec,&vvals);CHKERRV(ierr);
    loop(n) %{ $v(d=>i) = PetscRealPart(vvals[n]); %}
    ierr = VecRestoreArray(vvec,&vvals);CHKERRV(ierr);
  }

  //-- cleanup
  SVDDEBUG(fprintf(stderr, "cleanup\n");fflush(stderr);)
  ierr = VecDestroy(&uvec);CHKERRV(ierr);
  ierr = VecDestroy(&vvec);CHKERRV(ierr);
  ierr = SVDDestroy(&svd);CHKERRV(ierr);
  ierr = MatDestroy(&A);CHKERRV(ierr);
  svdslepc_finish_func(argc,argv);
'),
   Doc =>
q(

Compute the (truncated) singular value decomposition of a sparse matrix
using a L<SLEPc SVD solver|http://slepc.upv.es/documentation/current/docs/manualpages/SVD/>.
The sparse input matrix with $m() logical rows and $n() logical columns
is passed in encoded in Harwell-Boeing sparse format in the input parameters $rowptr(), $colids(),
and $nzvals().  See L<PDL::CCS> for a way to acquire these parameters
from a dense input matrix, but note that for this function, the
row-pointer $rowptr() is of size ($m+1)
for a dense matrix $a with $m rows,
where $ptr($m)==$nnz is the total number of nonzero
values in $a.

The left singular components are returned in the matrix $u(),
the singular values themselved in the vector $s(), and the
right singular components in the matrix $v().  Note that
$u() and $v() must be specified explicitly
in the call, so that the degree of reduction (the size parameter $d)
can be determined.  If $d==min($m,$n), then a full decomposition
will be computed, and on return, $u() and $v() should be
variants (up to sign and specified error tolerance)
of the matrices returned by L<PDL::MatrixOps::svd()|PDL::MatrixOps::svd>.

Additional options to the underlying SLEPc and PETSc code can be passed
command-line style in the ARRAY-ref C<optsArray>; see the output of
L<slepc_svd_help()|slepc_svd_help> for a list of available options.
For exammple, in order to compute the SVD using the Thick-restart Lanczos method with at
most 128 iterations and a tolerance of 1e-5, you could call:

 _slepc_svd_crs($rowptr,$colids,$nzvals, $u,$s,$v, [qw(-svd_max_it 128 -svd_tol 1e-5)]);

... but note that the number of singular values to be computed is determined
by the PDL size parameter $d, clobbering any value specified by the option
parmeter C<-svd_nsv>.

),
);




##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## footer: pm additions
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

SLEPc by Carmen Campos, Jose E. Roman, Eloy Romero, and Andres Tomas.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

=head2 no abstract interface

There should really be a more general and abstract PDL interface to SLEPc/PETsc.


=head2 OpenMPI Errors

You might see OpenMPI errors such as the following when trying to use this module:

 mca: base: component find: unable to open /usr/lib/openmpi/lib/openmpi/mca_paffinity_hwloc: perhaps a missing symbol, or compiled for a different version of Open MPI? (ignored)

If you do, you probably need to configure your runtime linker to pre-load the OpenMPI libraries, e.g. with

 export LD_PRELOAD=/usr/lib/libmpi.so

or similar.  An alternative is to build OpenMPI with the C<--disable-dlopen> option.
See L<http://www.open-mpi.org/faq/?category=troubleshooting#missing-symbols> for details.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@cpan.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2015, Bryan Jurish.  All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself, either version 5.20.2 or any newer version of Perl 5
you have available.

=head1 SEE ALSO

L<perl(1)|perl>,
L<PDL(3perl)|PDL>,
L<PDL::CCS(3perl)|PDL::CCS>,
L<PDL::SVDLIBC(3perl)|PDL::SVDLIBC>,
the SLEPc documentation at L<http://slepc.upv.es/documentation/current/docs/index.html>.

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
